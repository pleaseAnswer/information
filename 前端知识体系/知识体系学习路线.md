## 知识体系学习路线

### HTML + CSS

#### HTML

##### 1. 语义化标签

* `section` `article` `main` `aside` `header` `footer` `nav` `figure` `figcation`

##### 2. h5离线缓存

###### 2.1 什么是h5离线缓存？

> 离线存储可以将站点的一些文件存储在本地，他是浏览器自己的一种机制，将需要的文件缓存
> 在没有网络时可以访问到缓存的对应的站点页面
> 有网络时，浏览器也会优先使用已离线存储的文件

* h5离线缓存是**基于一个新建的.appcache文件的缓存机制(不是存储技术)**，通过这个文件上的解析清单离线存储资源【清单：把需要离线存储在本地的文件列在一个`manifest`配置文件中】

![h5离线缓存](./img/h5离线缓存.png)

* **0211 什么是manifest？**
  * `manifest`(清单)是一个简单的文本文件，它的扩展名是任意的，定义需要缓存的文件、资源
  * 当第一次打开时，浏览器会自动缓存相应的资源

* **0212 manifest的特点？**
  * **离线浏览：**当网络断开时，可以继续访问你的页面
    * **访问速度快：**将文件缓存到本地，不需每次都从网络上请求
    * **稳定性：**做了`manifea`t缓存，遇到突发网络故障或者服务器故障，继续访问本地缓存

* **0213 manifest的使用？**
  > html新增了一个`manifest`属性，可以用来指定当前页面的manifest文件
  * 创建一个和html同名的manifest文件
  * **栗子**
    * 1）页面index.html，可以新建一个index.manifest文件
    * 2）给index.html的html标签添加如下属性：
      * `<html lang="en" manifest="index.manifest">`或`<html manifest="http://www.example.com/index.manifest">`
      * 说明
        * 1 manifest的引入可以使用相对路径|绝对路径，如果使用绝对路径，则你的manifest文件必须与你的站点挂在同一个域名下
        * 2 manifest文件可以保存为任意的扩展名，但`mine-type`必须是`text/cache-manifest`
      * `<html lang="en" manifest="index.manifest">`在服务器上部署时需要在服务器上添加相应的mime-type
    * 注意："/page-url/", "/page-url/?something", "/page-url/?something-else" manifest会当成不同的页面，所以manifest最好使用在SPA(单页应用)项目中
    * 在Chrmoe，可以使用`chrome://appcache-internals/`查看缓存在本地的资源文件

* **0214 manifest文件结构？**
* manifest文件代码结构：
![manifest文件代码结构](./img/manifest文件代码结构.png)
  * manifest文件，基本格式为三段：
    * **`CACHE`：标识出哪些文件需要缓存，可以是相对路径也可以是绝对路径**
    * **`NETWORK`[可选]：要绕过缓存直接读取的文件，可以使用通配符`*`**
    * **`FALLBACK`[可选]：当资源无法访问时，浏览器使用后备资源去替代**

```js
CACHE MANIFEST // 第一行是`CACHE MANIFEST`是必须的
# version 2021-01-23 // 以#开头的是注释，一般是版本号

CACHE: // 这里列出来的文件，第一次加载下来时，会被浏览器缓存在本地
./asset/css/common.css
./asset/css/iconfont.woff
./src/main.js

NETWORK: // 大多数网站使用*，*表示除CACHE指定文件外，其它页面都需要联网访问
*

FALLBACK: // 如果无法建立因特网连接，则用"404.html"替代/html5/目录中的所有文件
/html5/ /404.html
```

* **0215 如何更新缓存？**
  * **更新manifest文件**
    * 给manifest添加或删除文件，都可更新缓存
  * **通过javascript操作**
    * h5引入了操作离线缓存的方法：**`window.applicationCache.update();`**
  * **清除浏览器缓存**

> 代码实现**手动更新manifest缓存**，一旦webapp源码更新，会自动更新本地manifest缓存，使用户始终访问到最新的源码

```js
window.applicationCache.addEventListener('updateready', function(e) {
    if(window.applicationCache.statue
    == window.applicationCache.UPDATEREADY) {
        window.applicationCache.swapCache();
        if(
        confirm('A new version of this site is available. Load it ?')
        ) {
            window.location.read();
        } else {
            // manifest didnt changed. Nothing new to server.
        }
    }
}, false);
```

###### 2.2 http缓存与h5离线缓存有什么区别？

> 前端缓存分为**http缓存**和**浏览器缓存**；
> http缓存分为**强缓存**和**协商缓存**；
> 浏览器缓存分为**离线缓存**和**本地缓存（cookie, webstorage等）**

* http缓存和h5缓存可以缓存任何资源（包括API接口）
* h5离线缓存的优势主要有两个：
* 1. **配置与WebServer解耦。**一般来所，静态资源想做http缓存是需要修改WebServer配置的
* 2. **完全脱机。**http缓存其实还有一次网络请求，利用了`Cache-Control`、`ETag`、`Last-Modified`、`If-Modified-Since`、`If-None-Match`这几个标头，服务端返回304状态码告知浏览器可以使用之前的资源，**节省的是该资源本身传输的网络开销，但并没有真正省去网络请求本身。**h5离线缓存则是一旦缓存成功，就完全脱机化了，直到`manifest`发生变化。

##### 3. 可以使用Canvas API、SVG等绘制高性能的动画

#### CSS

##### 1.@规则 -- 嵌套规则

> @[KEYWORD]{ /*嵌套语句*/ }

* 1. @font-face

```css
@font-face {
    font-family: "MyWebFont";
    src: url("myfont.woff2") format("woff2");
}
```

* 2. @keyframes -- C3动画

```css
@keyframes fadeIn {
    0% {
        opacity: 0;
    }
    100% {
        opacity: 1;
    }
}
```

* 3. @media 媒介查询

```css
@media all and (min-width: 1280px) {
    //
}
```

##### 2. css伪类和伪元素的区别和实际应用

* 伪类：相当于一个状态开关，需要手动触发，触发开关时修改元素样式达到动态效果
* 伪元素：可以比作一个假的元素，但不存在于dom树中，通常用来向元素添加小图标、清除浮动影响等

##### 3. 页面布局之文档流

###### 3.1 什么是文档流？

* 文档流指的是元素排版布局过程中，元素会默认从左往右，从上往下的流式排列方式。并最终窗体自上而下分成一行行，并在每行中从左至右的顺序排放元素。

###### 3.2 html标签在文档流中是怎样排列的？

* 块级元素在标准文档流中独占一行，不能与其它任何元素并列。多个块级元素垂直排列。
* 行内元素在标准文档流中没有宽高，与其它元素并排。

### js基础
### 计算机基础
### 数据结构和算法
### 框架和类库
### 运行环境

