### 算法

#### 1. 介绍下深度优先遍历和广度优先遍历，如何实现？

##### 深度优先遍历--栈

* 是指从某个顶点出发，首先访问这个顶点，然后找出刚访问这个结点的第一个未被访问的邻结点，然后再以此邻结点为顶点，继续找它的下一个顶点进行访问。重复此步骤，直至所有结点都被访问完为止。

```js
// 递归写法
function deepTraversal(node) {
  let nodes = [];
  if(node != null) {
    nodes.push(node);
    let childrens = node.children;
    for(let i = 0; i < childrens.length; i++) {
      deepTraversal(childrens[i])
    }
    return nodes;
  }
}
// 非递归写法
function deepTraversal(node) {
  let nodes = [];
  if(node != null) {
    let stack = []; // 存放将要访问的节点
    stack.push(node);
    while(stack.length != 0) {
      let item = stack.pop(); // 正在访问的节点
      nodes.push(item);
      let childrens = item.children;
      for(let i = childrens.length - 1; i >= 0; i--) {
        stack.push(childrens[i]);
      }
    }
    return nodes;
  }
}
```

##### 广度优先遍历--队列

* 是从某个顶点出发，首先访问这个顶点，然后找出刚访问这个结点所有未被访问的邻结点，访问完后再访问这些结点中第一个邻结点的所有结点，重复此方法，直到所有结点都被访问完为止。

```js
// 递归写法
function wideTraversal(node) {
  let nodes = [], i = 0;
  if(node != null) {
    nodes.push(node);
    wideTraversal(node.nextElementSibling)
    node = nodes[i++];
    wideTraversal(node.firstElementChild)
  }
  return nodes;
}
// 非递归写法
function wideTraversal(node) {
  let nodes = [];
  let stack = [];
  if(node != null) {
    stack.push(node)
    while (stack.length) {
      let item = stack.shift()
      let children = item.children
      nodes.push(item)
      for (let i = 0; i < children.length; i++) {
        stack.push(children[i])
      }
    }
  }
  return nodes;
}
```

#### 3. 冒泡排序如何实现，时间复杂度是多少，还可以如何改进？

##### 冒泡排序的原理

* 升序冒泡：两次循环，相邻元素两两比较，如果前面的大于后面的就交换位置
* 降序冒泡：两次循环，相邻元素两两比较，如果前面的小于后面的就交换位置

```js
// 升序冒泡
function maopao(arr) {
  const array = [...arr];
  for(let i = 0, len = array.length; i < len - 1; i++) {
    for(let j = i + 1; j < len; j++) {
      if(array[i] > array[j]) {
        let temp = array[i];
        array[i] = array[j];
        array[j] = temp;
      }
    }
  }
  return array;
}
```

* 效率低下，冒泡排序在平均和最坏情况下的事件复杂度是O(n^2)，最好情况下是O(n)，空间复杂度是O(1)
* 加个标识，如果已经排序好了就直接跳出循环

```js
function maopao(arr) {
  const array = [...arr];
  let isOk = true;
  for(let i = 0, len = array.length; i < len - 1; i++) {
    for(let j = i + 1; j < len; j++) {
      if(array[i] > array[j]) {
        let temp = array[i];
        array[i] = array[j];
        array[j] = temp;
        isOk = false;
      }
    }
    if(isOk) break;
  }
  return array;
}
```

#### 4. 给定两个数组，写一个方法来计算它们的交集？

#### 5. 实现一个字符串匹配算法，从长度n的字符串S中，查找是否存在字符串T，T的长度是m，若存在返回所在位置

#### 6. 随机生成一个长度为10的整数类型的数组，例如 `[2, 10, 9, 5, 3, 4, 11]`，将其排列成一个新数组，要求新数组形式如下，例如 `[[2, 3, 4, 5], [9, 10], [11]]`

#### 7. 如何把一个字符串的大小写取反，例如'Abc'变成'aBC'

#### 8. 打印出1-10000之间的所有对称数

#### 9. 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请找出这两个 有序数组的中位数。要求算法的时间复杂度为 O(log(m+n))

#### 16. 两个数组合并成一个数组

##### 请把两个数组 `['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2']` 和 `['A', 'B', 'C', 'D']`，合并 为 `['A1', 'A2', 'A', 'B1', 'B2', 'B', 'C1', 'C2', 'C', 'D1', 'D2', 'D']`

### 编码题

#### 1.已知数组，编写一个程序将数组扁平化并去除其中重复的部分数据，最终得到一个升序且不重复的数组

##### 题目

> `var arr = [[1, 2, 3], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10]`

##### 编码

* 使用`Set`方法去重，`flat(Infinity)`扁平化

```js
Array.from(new Set(arr.flat(Infinity))).sort((a, b) => { return a - b })
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
```
