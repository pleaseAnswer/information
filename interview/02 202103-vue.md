### 框架

#### 1. 写React/vue项目时为什么要在列表组件中写key，其作用是什么？

> `key`是给每一个`vnode`的**唯一id**，可以依赖key，`更准确`，`更快`的拿到`oldVnode`中对应的vnode节点。

1. 更准确
   * 因为带`key`就不是`就地复用`了，在`a.key === b.key`对比中可以避免就地复用的情况。所以会更准确。
2. 更快
   * 利用`key`的唯一性生成`map对象`来获取对应的节点，比遍历方式更快。

#### 2. 介绍下npm模块安装机制，为什么输入npm install就可以自动安装对应的模块？

##### npm模块安装机制

1. 发出`npm install`命令
2. 查询`node_modules`目录之中是否已经存在指定模块
   * 若存在，不再重新安装
   * 若不存在
     1. `npm`向`registry`查询模块压缩包的网址
     2. 下载压缩包，存放在根目录下的`.npm目录`里
     3. 解压压缩包到当前项目的`node_modules目录`

#### 3. 介绍下观察者模式和订阅-发布模式的区别，各适用于什么场景？

##### 区别

* **观察者模式中主体和观察者是相互感知的；发布-订阅模式是借助第三方来实现调度的，发布者和订阅者之间互不感知**

![观察者模式&发布-订阅模式](./img/观察者模式&发布-订阅模式.png)

1. 在**观察者模式**中，观察者是知道`Subject`的，`Subject`一直保持对观察者进行记录；在**发布订阅模式**中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。
2. 在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。
3. **观察者模式**大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法；而发布-订阅模式大多数时候是异步的（使用消息队列）。
4. **观察者模式**需要在单个应用程序地址空间中实现，而**发布-订阅**更像交叉应用模式。

#### 4. 介绍下webpack热更新原理，是如何做到在不刷新浏览器的前提下更新页面的？

1. 当修改了一个或多个文件；
2. 文件系统接收更改并通知`webpack`；
3. `webpack`重新编译构建一个或多个模块，并通知`HMR服务器`进行更新；
4. `HMR Server`使用`webSocket`通知`HMR runtime`需要更新，`HMR`运行时,通过`HTTP请求`更新`jsonp`；
5. `HMR`运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。

#### 5. 聊聊Vue的双向数据绑定，Model如何改变View，View又是如何改变Model的？

##### 核心思想

* 关注`Model`的变化，让`MVVM框架`利用自己的机制去`自动更新DOM`，从而把开发者从操作`DOM`的繁琐中解脱

##### Model -> (vm) -> View

* 从`model`到`view`的映射(data binding)，可以节省操作`update view`的代码

> `v-bind:value='val'`

##### View -> (vm) -> Model

* 从`view`到`model`的事件监听(dom listeners)，`model`会随着`view`触发事件而改变

> `v-on:input='val=$event.target.value'`
> `<input type="text" v-model="scole.English">`  [指令：v-model]

#### 6. Virtual DOM真的比操作原生DOM快吗？

##### 1. 原生DOM操作vs通过框架封装操作

* 这是一个`性能`vs`可维护性`的取舍。
* 框架的意义在于**为你掩盖底层的`DOM`操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。**
* 没有任何框架可以比纯手动的优化`DOM`操作更快，因为框架的`DOM`操作层需要应对任何上层`API`可能产生的操作，它的实现必须是普适的。

##### 2.性能比较也要看场合

1. 分清楚**初始渲染、小量数据更新、大量数据更新**这些不同场合。
2. **Virtual DOM、脏检查MVVM、数据收集MVVM**在不同场合各有不同的表现和不同的优化需求。
3. **Virtual DOM为了提高小量数据更新时得性能，也需要针对性的优化**

* 初始渲染：Virtual DOM > 脏检查 >= 依赖收集
* 小量数据更新：依赖收集 >> Virtual DOM + 优化 > 脏检查(无法优化) > Virtual DOM无优化
* 大量数据更新：脏检查+优化 >= 依赖收集 + 优化 > Virtual DOM(无优化) >> MVVM无优化

#### 7. 在vue中，子组件为何不可以修改父组件传递的prop？

> 因为`vue`设计是单向数据流，数据的流动方向只能是自上往下的方向

#### 8. 为什么Vuex的mutation不能做异步操作？

* Vuex中所有的状态更新的唯一途径都是`mutation`，异步操作通过`Action`来提交`mutation`实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。
* 每个`mutation`执行完成后都会对应到一个新的状态变更，这样`devtools`就可以打个快照存下来，然后就可以实现`time-travel`了。如果`mutation`支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。

#### 9. 双向绑定和vuex是否冲突？

> 严格模式中使用`vuex`时，在属于`vuex`的`state`上使用`v-model`会比较棘手

##### 栗子

```js
<input v-model="obj.message">
```

###### 解析

1. 假设`obj`是在计算属性中返回的一个属于`vuex store`的对象
2. 用户输入时，`v-model`会试图直接修改`obj.message`
3. 在严格模式中，由于这个修改不是在`mutation`函数中执行的，这里会抛出一个错误

###### vuex思维

> 用`vuex思维`去解决这个问题的方法是：**给`<input>`中绑定`value`，然后侦听`input`或者`change`事件，在事件回调中调用一个方法：**

```js
<input :value="message" @input="updateMessage">

computed: {
  ...mapState({
    message: state => state.obj.message
  })
},
methods: {
  updateMessage(e) {
    this.$store.commit('updateMessage', e.target.value)
  }
}

// vuex中的mutation函数
mutations: {
  updateMessage(state, message) {
    state.obj.message = message
  }
}
```

###### 双向绑定的计算属性

> 使用带有`setter`的双向绑定计算属性

```js
<input v-model="message">

computed: {
  message: {
    get() {
      return this.$store.state.obj.message
    },s
    et(value) {
      this.$store.commit('updateMessage', value)
    }
  }
}
```

#### 10. Vue父组件和子组件生命周期钩子执行顺序是什么？

1. 加载渲染过程： `父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMounted -> 子mounted`
2. 子组件更新过程：`父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated`
3. 父组件更新过程：`父beforeUpdate -> 父updated`
4. 销毁过程：`父beforeDestory -> 子beforeDestory -> 子destoryed -> 父destoryed`

#### 11. Vue在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？

##### 事件代理（事件委托）

###### 什么是事件代理？

* 如果某些标签当前不存在，未来才可能被创建出来，我们无法直接给他们添加事件，到那时可以把这个操作添加到这些元素的祖先节点身上

###### 事件代理的作用？

* 事件代理能够避免我们逐个去给元素新增和删除事件
* 事件代理比每一个元素都绑定一个事件性能要更好

* **总结**
  1. 将事件处理程序代理到父节点，减少内存占用率
  2. 动态生成子节点时能自动绑定事件处理程序到父节点

##### 没必要

* 在`v-for`中，我们直接使用`for循环`就能在模板上将每个元素都绑定事件，并且当组件销毁时，vue也会自动给我们将所有的事件处理器移除。所以事件代理能做到的第一点vue已经做到了
* 在`v-for`中，给元素绑定的都是相同的事件，所以除非上千行的元素需要加上事件，其实和使用事件代理的性能差别不大，所以没必要用事件代理

#### 12. 