## Vue框架

### Vue

#### 1. vue的工作原理

* **`vue`是一个构建`数据驱动`的web界面的`渐进式框架`，采用`MVVM模式`实现视图层与数据层的数据修改、更新监听。**
* **其工作原理是`vue`在实例化的过程中会遍历`data`下的数据，通过`Object.defineProperty()`方法将它们设置为存储器属性（即具有`getter`、`setter`属性）。**

#### 5. Vue的双向数据绑定，Model如何改变View，View又是如何改变Model的？

##### 核心思想

> `MVVM`是一个构建数据驱动的渐进式框架：关注`Model`的变化，让`MVVM框架`利用自己的机制去`自动更新DOM`，从而把开发者从操作`DOM`的繁琐中解脱

* `MVVM`分为`Model`、`View`、`ViewModel`三者。`Model是数据层`，`View是视图层`，Model和View并无直接联系，而是通过`ViewModel`进行联系。`Model和ViewModel之间存在双向绑定的联系`。因此当Model中的数据改变时会**触发**View层的刷新，View层中由于用户交互操作而改变的数据也会在Model中**同步**。这种模式实现了Model和View的数据自动同步，因此开发者只需要专注于对数据的维护即可，而不需要自己操作dom

##### Model -> (vm) -> View

* 从`model`到`view`的映射(data binding)，可以节省操作`update view`的代码

> `v-bind:value='val'`

##### View -> (vm) -> Model

* 从`view`到`model`的事件监听(dom listeners)，`model`会随着`view`触发事件而改变

> `v-on:input='val=$event.target.value'`
> `<input type="text" v-model="scole.English">`  [指令：v-model]

#### 3. vue的特点

1. **简洁**：页面由HTML模板+ JSON数据+ Vue实例组成；
2. **数据驱动**：自动计算属性和追踪依赖的模板表达式；
3. **组件化**：用可复用、解耦的组件来构造页面；
4. **轻量**：代码量小，不依赖其他库；
5. **快速**：精确有效批量DOM更新。

#### 4. 为什么vue中的data必须是一个函数？

* 对象是引用类型，在重用组件时，由于数据对象指向同一个`data`对象，当在一个组件中修改`data`时，其它重用的组件中的`data`会同时被修改。使用返回对象的函数，由于每次返回的是一个新的对象，引用地址不同，就不会出现这个问题。

#### 2. vue中的ref是什么？

* ref被用来给组件或元素注册引用信息，然后引用信息会注册在父组件的$refs对象上。也就是说如果在普通dom上使用，引用指向的就是dom元素；如果用在子组件上，引用指向的就是组件实例。

#### 1. 写React/vue项目时为什么要在列表组件中写key，其作用是什么？

> `key`是给每一个`vnode`的**唯一id**，可以依赖key，`更准确`，`更快`的拿到`oldVnode`中对应的vnode节点。

1. 更准确
   * 因为带`key`就不是`就地复用`了，在`a.key === b.key`对比中可以避免就地复用的情况。所以会更准确。
2. 更快
   * 利用`key`的唯一性生成`map对象`来获取对应的节点，比遍历方式更快。

#### 4. watch和computed计算属性的区别？

> 既能用`computed`实现又可以用`watch`监听来实现的功能，推荐用`computed`。重点在于`computed的缓存功能`。

* **`computed计算属性`用来声明式地描述一个值依赖了其他值，当他所依赖的值或变量发生改变时，计算属性也会跟着改变**
* **`watch`用来监听实例下的属性，当监听的值发生改变时会自动调用对应的方法**

#### 10. Vue父组件和子组件生命周期钩子执行顺序是什么？

1. 加载渲染过程： `父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMounted -> 子mounted`
2. 子组件更新过程：`父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated`
3. 父组件更新过程：`父beforeUpdate -> 父updated`
4. 销毁过程：`父beforeDestory -> 子beforeDestory -> 子destoryed -> 父destoryed`

#### 11. Vue在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？

##### 事件代理（事件委托）

###### 什么是事件代理？

* 如果某些标签当前不存在，未来才可能被创建出来，我们无法直接给他们添加事件，到那时可以把这个操作添加到这些元素的祖先节点身上

###### 事件代理的作用？

* 事件代理能够避免我们逐个去给元素新增和删除事件
* 事件代理比每一个元素都绑定一个事件性能要更好

* **总结**
  1. 将事件处理程序代理到父节点，减少内存占用率
  2. 动态生成子节点时能自动绑定事件处理程序到父节点

##### 没必要

* 在`v-for`中，我们直接使用`for循环`就能在模板上将每个元素都绑定事件，并且当组件销毁时，vue也会自动给我们将所有的事件处理器移除。所以事件代理能做到的第一点vue已经做到了
* 在`v-for`中，给元素绑定的都是相同的事件，所以除非上千行的元素需要加上事件，其实和使用事件代理的性能差别不大，所以没必要用事件代理

#### 6. Virtual DOM真的比操作原生DOM快吗？

> 虚拟dom：一个结构类似于真实DOM节点的js对象

##### 1. 原生DOM操作vs通过框架封装操作

* 这是一个`性能`vs`可维护性`的取舍。
* 框架的意义在于**为你掩盖底层的`DOM`操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。**
* 没有任何框架可以比纯手动的优化`DOM`操作更快，因为框架的`DOM`操作层需要应对任何上层`API`可能产生的操作，它的实现必须是普适的。

##### 2.性能比较也要看场合

1. 分清楚**初始渲染、小量数据更新、大量数据更新**这些不同场合。
2. **Virtual DOM、脏检查MVVM、数据收集MVVM**在不同场合各有不同的表现和不同的优化需求。
3. **Virtual DOM为了提高小量数据更新时的性能，也需要针对性的优化**

* 初始渲染：Virtual DOM > 脏检查 >= 依赖收集
* 小量数据更新：依赖收集 >> Virtual DOM + 优化 > 脏检查(无法优化) > Virtual DOM无优化
* 大量数据更新：脏检查+优化 >= 依赖收集 + 优化 > Virtual DOM(无优化) >> MVVM无优化

#### 4. v-show和v-if的相同点和不同点

* `v-show`指令是通过`修改元素的display属性`让其显示或隐藏。
* `v-if`是直接`销毁和重建DOM`达到让元素显示和隐藏的效果。

#### 4. v-on常用修饰符

* `.native`主要是给自定义组件添加原生事件
* `.stop`主要用于阻止事件冒泡
  * `e.stopPropagation()`
* `.prevent`主要用于阻止当前事件的默认行为
* `.self`主要用于设置当事件是从事件绑定的元素本身触发时才会触发回调
* `.once`表示绑定的事件是一次性的，仅被触发一次

### 组件化

#### 7. 在vue中，子组件为何不可以修改父组件传递的prop？

> 因为`vue`设计是单向数据流，数据的流动方向只能是自上往下的方向

#### 2. 组件通讯

##### 1.父传子

* 父：自定义属性名+ 数据
* 子：`props["父组件上的自定义属性名"]`
　　
##### 2.子传父

> **在父组件中注册子组件并在子组件标签上绑定自定义事件的监听**

* 子：`this.$emit("自定义事件名"，数据) + 子组件标签上绑定@自定义事件名 = "回调函数"`
* 父：`methods: {自定义事件() {}}`
　　
##### 3.事件总线  `let bus = new Vue()`

* A：`methos:{函数{bus.$emit("自定义事件名"，数据)}}` -> 发送
* B：`created(){bus.$on("A发送过来的自定义事件名")}` -> 接收

### Vue-Cli

#### 7.vue-cli项目中src目录中每个文件夹和文件的用法

* assets：放静态资源
* component：放组件
* router：定义路由相关的配置
* app.vue：是一个应用主组件
* main.js：是入口文件

### Vue-Router

#### 3. vue的路由模式及实现方式？

> `hash` && `history`

##### hash

* hash路由原理是window下的hashchange事件，它会在浏览器url地址中hash值改变时触发
* hash虽然在url中，但不被包括在http请求中，只用来指导浏览器动作，对浏览器安全无用，hash不会重加载页面

##### history

* history路由采用了h5的新特性，h5提供了pushState()和replaceState()实现不刷新页面的路由跳转
* history模式需要后台配合配置。

#### 7. vue-router有哪几种导航钩子？

##### 1. 全局导航钩子

> 可以用在路由跳转前做判断拦截

* 所有的路由切换都会执行，一般写在路由配置文件中
* **`router.beforeEach(fn)`**
  * to
  * from
  * next()

* **router.afterEach(fn)**
  * to
  * from

##### 2. 组件内钩子

* **beforeRouteEnter(fn)**
  > 此时组件实例还没有被创建，因此无法访问this
  * to
  * from
  * next()

* **beforeRouteUpdate(fn)**
  * to
  * from
  * next()

* **beforeRouteLeave(fn)**
  * to
  * from
  * next()

##### 3. 路由独享钩子

* 写在路由配置中
* **beforeEnter(fn)**
  * to
  * from
  * next()

#### 3. vue路由传参

* 使用`query方式`传入的参数使用`this.$route.query`接收：`query传参`可通过`path`和`name`方式跳转，页面刷新参数任然存在；
* 使用`params方法`传入的参数使用`this.$route.params`接收：`params传参`只能通过`name`方式跳转，页面刷新时params参数会丢失，除非作为动态路由

### Vuex

#### 1. vuex是什么？有哪几种属性？

* `vuex`是一个专门为vue.js程序开发的状态管理模式。有五种属性：`state`、`getter`、`mutation`、`action`、`module`

#### 2. vuex的state是什么？

* `vuex`就是一个`store`，`store`里面放了很多对象。
* 其中`state`就是数据源存放地，`对应于vue中的data`。
* `state`里存放的数据是响应式的，`vue`从`store`中读取数据，当`store`中的数据发生改变时，依赖这些数据的组件也会发生改变。
* 它通过`mapState`把全局的`state`和`getter`映射到当前组件的`computed`属性。

#### 3. vuex的getter是什么？

* `getter`用来对`state`进行计算操作，它就是`store`的计算属性。
* `getter`的返回值会根据它的依赖被缓存起来，且只有当它依赖的值发生了改变才会被重新计算，`getter`可以用于监听`state`中的值的变化，返回计算后的结果。
* 虽然在组件内也可以做计算属性，但是`getter`可以在多组件复用。
* 它对应于`vue`对象中的`computed`。

#### 4. vuex的mutation是什么？

* 更改`vuex`中`store`中的`state`的唯一方法是通过`this.$store.commit`提交`mutation`。

#### 5. vuex的action是什么？

* `action`类似于`mutation`，不同的是`action`的是通过`this.$store.dispatch`提交`mutation`，而不是直接变更状态。
* `action`可以包含任何异步操作。

#### 8. 为什么Vuex的mutation不能做异步操作？

* Vuex中所有的状态更新的唯一途径都是`mutation`，异步操作通过`Action`来提交`mutation`实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。
* 每个`mutation`执行完成后都会对应到一个新的状态变更，这样`devtools`就可以打个快照存下来，然后就可以实现`time-travel`了。如果`mutation`支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。

#### 9. 双向绑定和vuex是否冲突？

> 严格模式中使用`vuex`时，在属于`vuex`的`state`上使用`v-model`会比较棘手

##### 栗子

```js
<input v-model="obj.message">
```

###### 解析

1. 假设`obj`是在计算属性中返回的一个属于`vuex store`的对象
2. 用户输入时，`v-model`会试图直接修改`obj.message`
3. 在严格模式中，由于这个修改不是在`mutation`函数中执行的，这里会抛出一个错误

###### vuex思维

> 用`vuex思维`去解决这个问题的方法是：**给`<input>`中绑定`value`，然后侦听`input`或者`change`事件，在事件回调中调用一个方法：**

```js
<input :value="message" @input="updateMessage">

computed: {
  ...mapState({
    message: state => state.obj.message
  })
},
methods: {
  updateMessage(e) {
    this.$store.commit('updateMessage', e.target.value)
  }
}

// vuex中的mutation函数
mutations: {
  updateMessage(state, message) {
    state.obj.message = message
  }
}
```

###### 双向绑定的计算属性

> 使用带有`setter`的双向绑定计算属性

```js
<input v-model="message">

computed: {
  message: {
    get() {
      return this.$store.state.obj.message
    },s
    et(value) {
      this.$store.commit('updateMessage', value)
    }
  }
}
```

### 其它

#### 2. 介绍下npm模块安装机制，为什么输入npm install就可以自动安装对应的模块？

##### npm模块安装机制

1. 发出`npm install`命令
2. 查询`node_modules`目录之中是否已经存在指定模块
   * 若存在，不再重新安装
   * 若不存在
     1. `npm`向`registry`查询模块压缩包的网址
     2. 下载压缩包，存放在根目录下的`.npm目录`里
     3. 解压压缩包到当前项目的`node_modules目录`

#### 3. 介绍下观察者模式和订阅-发布模式的区别，各适用于什么场景？

##### 区别

* **观察者模式中主体和观察者是相互感知的；发布-订阅模式是借助第三方来实现调度的，发布者和订阅者之间互不感知**

![观察者模式&发布-订阅模式](./img/观察者模式&发布-订阅模式.png)

1. 在**观察者模式**中，观察者是知道`Subject`的，`Subject`一直保持对观察者进行记录；在**发布订阅模式**中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。
2. 在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。
3. **观察者模式**大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法；而发布-订阅模式大多数时候是异步的（使用消息队列）。
4. **观察者模式**需要在单个应用程序地址空间中实现，而**发布-订阅**更像交叉应用模式。

#### 4. 介绍下webpack热更新原理，是如何做到在不刷新浏览器的前提下更新页面的？

1. 当修改了一个或多个文件；
2. 文件系统接收更改并通知`webpack`；
3. `webpack`重新编译构建一个或多个模块，并通知`HMR服务器`进行更新；
4. `HMR Server`使用`webSocket`通知`HMR runtime`需要更新，`HMR`运行时,通过`HTTP请求`更新`jsonp`；
5. `HMR`运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。
